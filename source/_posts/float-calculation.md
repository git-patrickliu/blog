title: float-calculation
date: 2015-12-13 18:37:29
tags: 浮点数计算
- js float
- js 浮点数计算
---

话说某天一个同事问我，为啥在JS里面 **0.2+0.4**，结果不是**0.6**。我想这个问题随便问一个人，都可以得出结果就是**0.6**， 而JS计算之后的结果是：

![0.2+0.4 result](http://onlineimages.dapenggaofei.com/ff2efb5a2f58b399125a02c805e3b560.png)

下面我们来回忆一下学习过的计算机组成原理相关的知识。一步一步来揭示这个问题的真相。

### 浮点数的表示
先介绍一下在计算机中表示数字的三种表示方法：[原码](http://baike.baidu.com/view/60480.htm)，[反码](http://baike.baidu.com/view/742694.htm)和[补码](http://baike.baidu.com/link?url=OeFyHF5lRc_3X8oaLrMYQZIJwtgbSlbq4u5fgXwWvYmUl8DY6LARZ0NvnxJakDjN8HFqtjoHXz0pSWVvkE_OPa)

#### 1. 原码
原码是计算机中对数字的二进制的定点表示方法。

优点是简单直观。最高位表示符号位。例如我们用8位二进制来表示一个数。
> +11的原码为`0`0001011，-11的原码就是`1`00001011。

缺点是不能直接参与运算，可能会出错。例如数学上，1+(-1)=0，但在二进制当中00000001+10000001=10000010，换自成十进制就是-2，结果显示是错误的。所以原码的符号位不能直接参与运算，必须和其他位分开，这就增加了实现的硬件开稍和复杂性。

用于表示整数的原码，如果不满位长，如8，则在高位和符号位间添加0，补全。
> 如前面的11的例子。如小数，则在最低位往后补0。如0.375的原码二制度为0.011`0000`。后四位为补全8位的码。



Q1: -12.875的原码表示为？
Q2: 8位有符号原码，可表示的数值范围是？


#### 2. 反码
正数的反码与其原码相同。
负数的反码，符号位为`1`, 数值部位按原码取反。
> 例如：
> [+7]原=00000111
> [+7]反=00000111
> [-7]原=10000111
> [-7]反=11111000

Q3: 8位有符号的反码，可表示的数值范围是？

#### 3. 补码
正数的补码和其原码相同。
负数的补码，为其反码+1。
>例如：
> [+7]原=00000111
> [+7]反=00000111
> [+7]补=00000111
> [-7]原=10000111
> [-7]反=11111000
> [-7]补=11111001

Q4: 8位有符号的补码，可表示的数值范围是？

#### 溢出
(+72) + (+98) = ?? （8位有符号数）

#### 浮点数表示方法
根据国际标准 *IEEE 754*，任意一个二进制浮点数V可以表示成下面的形式。
> ![IEEE754](http://7xlxn1.com1.z0.glb.clouddn.com/74fce14dc02783bde16b5d38fa92babd.png)
> 1. (-1)^s表示符号位，当s=0，V为正数；当s=1，V为负数。
> 2. M表示有效数字，大于等于1，小于2。
> 3. 2^E表示指数位。

举例来说，十进制的5.0，写成二进制就是101.0，相当于1.01*2^2。那么，按照上述公式，可以得出s=0, M=1.01, E=2。

十进制的-5.0，写成二进制就是-101.0，相当于-1.01*2^2。那么s=1, M=1.01, E=2。

*IEEE 754* 规定，对于32位的浮点数，最高1位是符号位s, 接着的8位是指数E，剩下的23位是有效数字M。对于64位的浮点数，最高1位是符号位s，接着的11位是指数E，剩下的52位为有效数字M。

*IEEE 754* 对有效数字M和指数E，还有一些特别规定。

> 前面说过，1<=M<2，也就是说M可以写成1.xxxxxx的形式，其中xxxxxx表示小数部分。*IEEE 754*规定，在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxxx部分，比如保存1.01的时候，只保存01，等到读取的时候，再把第一位的1加上去，这样的目的，是节省了1位有效数字。

至于指数E，情况就比较复杂。

>首先，E为一个无符号的整数。这意味着，如果E为8位，它的取值范围为0～255，如果E为11位，它的取值范围为0～2047。但是，我们知道，科学计数法中的E是可以出现负数的，所以*IEEE 754*规定，E的真实值必须再减去一个中间数，对于8位的E，这个中间数就是127，对于11位的E，这个中间数就是1023。

比如，2^10的E是10，所以保存成32位浮点数时，必须保存为10+127=137，即10001001。

然后，指数E还可以再分成三种情况：

>(1) E不全为0或不全为1。这时，浮点数就采用上面的规则表示，即指数E的计算值减去127，得到真实值，再将有效数字M前加上第一位的1。
(2) E全为0。这时浮点数的指数E等于1-127，有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数，这样做是为了表示+-0，以及接近于0的很小的数字。
(3) E全为1。这时如果有效数字M全为0，表示+-无穷大。如果有效数字M不全为0，表示这个数不是一个数(NaN)。

#### 浮点数的加法
浮点数的加法的计算，需要进行以下5步。
一、 对阶
> 使两数的小数点位置对齐，小的阶码向大的阶码看齐。

    所谓对阶是指将两个进行运算的浮点数的阶码对齐的操作。对阶的目的是为使两个浮点数的尾数能够进行加减运算。因为，当进行Mx·2Ex与My·2Ey加减运算时，只有使两浮点数的指数值部分相同，才能将相同的指数值作为公因数提出来，然后进行尾数的加减运算。    对阶的具体方法是：首先求出两浮点数阶码的差，即⊿E＝Ex-Ey，将小阶码加上⊿E，使之与大阶码相等，同时将小阶码对应的浮点数的尾数右移相应位数，以保证该浮点数的值不变。
    
    几点注意:
    1. 对阶的原则是小阶对大阶，之所以这样做是因为若大阶对小阶，则尾数的数值部分的高位需移出，而小阶对大阶移出的是尾数的数值部分的低位，这样损失的精度更小。
    2. 若⊿E＝0，说明两浮点数的阶码已经相同，无需再做对阶操作了。
    3. 采用补码表示的尾数右移时，符号位保持不变。
    4. 由于尾数右移时是将最低位移出，会损失一定的精度，为减少误差，可先保留若干移出的位，供以后舍入处理用。

二、尾数求和
> 尾数运算就是进行完成对阶后的尾数相加减。这里采用的就是我们前面讲过的纯小数的定点数加减运算。

三、规格化

在机器中，为保证浮点数表示的唯一性，浮点数在机器中都是以规格化形式存储的。对于IEEE754标准的浮点数来说，就是尾数必须是1.M的形式。由于在进行上述两个定点小数的尾数相加减运算后，尾数有可能是非规格化形式，为此必须进行规格化操作。

规格化操作包括左规和右规两种情况。    左规操作：将尾数左移，同时阶码减值，直至尾数成为1.M的形式。例如，浮点数0.0011·25是非规格化的形式，需进行左规操作，将其尾数左移3位，同时阶码减3，就变成1.1100·22规格化形式了。    右规操作：将尾数右移1位，同时阶码增1，便成为规格化的形式了。要注意的是，右规操作只需将尾数右移一位即可，这种情况出现在尾数的最高位（小数点前一位）运算时出现了进位，使尾数成为10.xxxx或11.xxxx的形式。例如，10.0011·25右规一位后便成为1.00011·26的规格化形式了。

四、舍入

浮点运算在对阶或右规时，尾数需要右移，被右移出去的位会被丢掉，从而造成运算结果精度的损失。为了减少这种精度损失，可以将一定位数的移出位先保留起来，称为保护位，在规格化后用于舍入处理。   IEEE754标准列出了四种可选的舍入处理方法：   
  1. 就近舍入（round to nearest） 这是标准列出的默认舍入方式，其含义相当于我们日常所说的“四舍五入”。例如，对于32位单精度浮点数来说，若超出可保存的23位的多余位大于等于100…01，则多余位的值超过了最低可表示位值的一半，这种情况下，舍入的方法是在尾数的最低有效位上加1；若多余位小于等于011…11，则直接舍去；若多余位为100…00，此时再判断尾数的最低有效位的值，若为0则直接舍去，若为1则再加1。   
  2. 朝+∞舍入（round toward +∞） 对正数来说，只要多余位不为全0，则向尾数最低有效位进1；对负数来说，则是简单地舍去。   
  3. 朝-∞舍入（round toward -∞） 与朝+∞舍入方法正好相反，对正数来说，只是简单地舍去；对负数来说，只要多余位不为全0，则向尾数最低有效位进1。  
  4. 朝0舍入（round toward 0）    即简单地截断舍去，而不管多余位是什么值。这种方法实现简单，但容易形成累积误差，且舍入处理后的值总是向下偏差。


五. 判断结果
与定点数运算不同的是，浮点数的溢出是以其运算结果的阶码的值是否产生溢出来判断的。若阶码的值超过了阶码所能表示的最大正数，则为上溢，进一步，若此时浮点数为正数，则为正上溢，记为+∞，若浮点数为负数，则为负上溢，记为-∞；若阶码的值超过了阶码所能表示的最小负数，则为下溢，进一步，若此时浮点数为正数，则为正下溢，若浮点数为负数，则为负下溢。正下溢和负下溢都作为0处理。

#### 尝试解释一下下面的结果，然后在console当中试试

`0.7+0.2` = `?`

